import logging
import asyncio
import os
from background import keep_alive
from aiogram import Bot, Dispatcher, types
from aiogram.types import Message, FSInputFile, ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command
from PIL import Image

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞
API_TOKEN = '7553035806:AAFEF2N74kpaOswTQwkYkIsn0W_4PZ-Qs_U'

# –í–∫–ª—é—á–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä
bot = Bot(token=API_TOKEN)
dp = Dispatcher()
processing_lock = asyncio.Lock()
# –ü–∞–ø–∫–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
IMAGE_DIR = "images"
WATERMARK_DIR = "watermarks"
os.makedirs(IMAGE_DIR, exist_ok=True)
os.makedirs(WATERMARK_DIR, exist_ok=True)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
# –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é: "—Å–ø—Ä–∞–≤–∞" (–Ω–∏–∂–Ω–∏–π –ø—Ä–∞–≤—ã–π —É–≥–æ–ª)
watermark_positions = {}

# –û—Å–Ω–æ–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
menu_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –ª–æ–≥–æ—Ç–∏–ø")],
        [KeyboardButton(text="–í—ã–±—Ä–∞—Ç—å –º–µ—Å—Ç–æ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ")]
    ],
    resize_keyboard=True
)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
position_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="—Å–ª–µ–≤–∞"), KeyboardButton(text="—Å–ø—Ä–∞–≤–∞")],
        [KeyboardButton(text="–≤–≤–µ—Ä—Ö—É"), KeyboardButton(text="–≤–Ω–∏–∑—É")],
        [KeyboardButton(text="–ø–æ —Ü–µ–Ω—Ç—Ä—É")]
    ],
    resize_keyboard=True
)

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(Command("start"))
async def start_cmd(message: Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –ª–æ–≥–æ—Ç–∏–ø (JPG –∏–ª–∏ PNG).", reply_markup=menu_keyboard)

# –ö–æ–º–∞–Ω–¥–∞ /menu
@dp.message(Command("menu"))
async def menu_cmd(message: Message):
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=menu_keyboard)

# –£–¥–∞–ª–µ–Ω–∏–µ –ª–æ–≥–æ—Ç–∏–ø–∞
@dp.message(lambda message: message.text == "üóë –£–¥–∞–ª–∏—Ç—å –ª–æ–≥–æ—Ç–∏–ø")
async def delete_logo(message: Message):
    user_id = message.from_user.id
    watermark_path_jpg = os.path.join(WATERMARK_DIR, f"{user_id}.jpg")
    watermark_path_png = os.path.join(WATERMARK_DIR, f"{user_id}.png")

    if os.path.exists(watermark_path_jpg):
        os.remove(watermark_path_jpg)
    if os.path.exists(watermark_path_png):
        os.remove(watermark_path_png)

    await message.answer("‚úÖ –í–∞—à –ª–æ–≥–æ—Ç–∏–ø —É–¥–∞–ª—ë–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π –ª–æ–≥–æ—Ç–∏–ø.", reply_markup=menu_keyboard)

# –í—ã–±–æ—Ä –º–µ—Å—Ç–∞ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
@dp.message(lambda message: message.text == "–í—ã–±—Ä–∞—Ç—å –º–µ—Å—Ç–æ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ –Ω–∞ —Ñ–æ—Ç–æ")
async def choose_position(message: Message):
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—Ç–æ –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞:", reply_markup=position_keyboard)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
@dp.message(lambda message: message.text in ["—Å–ª–µ–≤–∞", "—Å–ø—Ä–∞–≤–∞", "–≤–≤–µ—Ä—Ö—É", "–≤–Ω–∏–∑—É", "–ø–æ —Ü–µ–Ω—Ç—Ä—É"])
async def set_position(message: Message):
    user_id = message.from_user.id
    watermark_positions[user_id] = message.text
    await message.answer(f"‚úÖ –ü–æ–∑–∏—Ü–∏—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {message.text}.", reply_markup=menu_keyboard)

# –ü—Ä–æ–≤–µ—Ä–∫–∞: –ï—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ª–æ–≥–æ—Ç–∏–ø?
def has_logo(user_id):
    return (
        os.path.exists(os.path.join(WATERMARK_DIR, f"{user_id}.png")) or
        os.path.exists(os.path.join(WATERMARK_DIR, f"{user_id}.jpg"))
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ª–æ–≥–æ—Ç–∏–ø–æ–≤ (—Ñ–∞–π–ª—ã JPG/PNG)
@dp.message(lambda message: message.document and not has_logo(message.from_user.id))
async def handle_document(message: Message):
    user_id = message.from_user.id
    document = message.document

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞
    file_ext = document.file_name.split('.')[-1].lower()
    if file_ext not in ["jpg", "jpeg", "png"]:
        await message.answer("‚ö† –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ñ–æ—Ä–º–∞—Ç—ã JPG –∏ PNG!")
        return

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ª–æ–≥–æ—Ç–∏–ø–∞
    watermark_path = os.path.join(WATERMARK_DIR, f"{user_id}.{file_ext}")
    file = await bot.get_file(document.file_id)
    await bot.download_file(file.file_path, watermark_path)

    await message.answer(f"‚úÖ –õ–æ–≥–æ—Ç–∏–ø ({file_ext.upper()}) —Å–æ—Ö—Ä–∞–Ω—ë–Ω! –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞.")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ª–æ–≥–æ—Ç–∏–ø–æ–≤ (—Ñ–æ—Ç–æ)
@dp.message(lambda message: message.photo and not has_logo(message.from_user.id))
async def handle_logo_photo(message: Message):
    user_id = message.from_user.id
    photo = message.photo[-1]
    file = await bot.get_file(photo.file_id)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–æ—Ç–æ –∫–∞–∫ JPG (Telegram —É–∂–µ –µ–≥–æ —Å–∂–∞–ª)
    watermark_path = os.path.join(WATERMARK_DIR, f"{user_id}.jpg")
    await bot.download_file(file.file_path, watermark_path)

    await message.answer("‚úÖ –õ–æ–≥–æ—Ç–∏–ø (JPG) —Å–æ—Ö—Ä–∞–Ω—ë–Ω! –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞.")
    await message.answer("‚ö† –ï—Å–ª–∏ —É –≤–∞—Å PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é, –∑–∞–≥—Ä—É–∂–∞–π—Ç–µ –µ–≥–æ –∫–∞–∫ –§–ê–ô–õ (üìé), –∏–Ω–∞—á–µ —Ñ–æ–Ω —Å—Ç–∞–Ω–µ—Ç –±–µ–ª—ã–º!")

@dp.message(lambda message: message.photo or (message.document and message.document.mime_type.startswith("image/")))
async def handle_image(message: Message):
    user_id = message.from_user.id

    async with processing_lock:  # –ë–ª–æ–∫–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ª–æ–≥–æ—Ç–∏–ø
        watermark_path = os.path.join(WATERMARK_DIR, f"{user_id}.png")
        if not os.path.exists(watermark_path):
            watermark_path = os.path.join(WATERMARK_DIR, f"{user_id}.jpg")

        if not os.path.exists(watermark_path):
            await message.answer("‚ö† –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –ª–æ–≥–æ—Ç–∏–ø (JPG –∏–ª–∏ PNG)!")
            return

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∏ –ø—É—Ç—å
        if message.photo:
            photo = message.photo[-1]
            file = await bot.get_file(photo.file_id)
            image_path = os.path.join(IMAGE_DIR, f"{user_id}.jpg")
        else:
            document = message.document
            file_ext = document.file_name.split('.')[-1].lower()
            if file_ext not in ["jpg", "jpeg", "png"]:
                await message.answer("‚ö† –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ JPG –∏ PNG!")
                return
            file = await bot.get_file(document.file_id)
            image_path = os.path.join(IMAGE_DIR, f"{user_id}.{file_ext}")

        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ
        await bot.download_file(file.file_path, image_path)

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        result_path = add_watermark(image_path, watermark_path, watermark_positions.get(user_id, "—Å–ø—Ä–∞–≤–∞"))
        photo_file = FSInputFile(result_path)
        await message.answer_document(photo_file, caption="‚úÖ –ì–æ—Ç–æ–≤–æ! –í–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫ –¥–æ–±–∞–≤–ª–µ–Ω.")


# –§—É–Ω–∫—Ü–∏—è –Ω–∞–ª–æ–∂–µ–Ω–∏—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–≥–æ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ —Å —É—á–µ—Ç–æ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
def add_watermark(image_path, watermark_path, position_choice):
    base_image = Image.open(image_path).convert("RGBA")
    watermark = Image.open(watermark_path).convert("RGBA")

    # –ò–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞ (20% –æ—Ç —à–∏—Ä–∏–Ω—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
    base_width, base_height = base_image.size
    wm_width = int(base_width * 0.2)
    wm_height = int(watermark.height * (wm_width / watermark.width))
    watermark = watermark.resize((wm_width, wm_height), Image.LANCZOS)

    # –°–æ–∑–¥–∞—ë–º –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª —Å 50% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
    alpha = watermark.split()[3]  # –ë–µ—Ä—ë–º –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª
    alpha = alpha.point(lambda p: p * 0.5)  # –£–º–µ–Ω—å—à–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ 50%
    watermark.putalpha(alpha)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞
    if position_choice == "—Å–ª–µ–≤–∞":
        position = (10, (base_height - wm_height) // 2)  # –¶–µ–Ω—Ç—Ä –ø–æ –≤—ã—Å–æ—Ç–µ —Å–ª–µ–≤–∞
    elif position_choice == "—Å–ø—Ä–∞–≤–∞":
        position = (base_width - wm_width - 10, (base_height - wm_height) // 2)  # –¶–µ–Ω—Ç—Ä –ø–æ –≤—ã—Å–æ—Ç–µ —Å–ø—Ä–∞–≤–∞
    elif position_choice == "–≤–≤–µ—Ä—Ö—É":
        position = ((base_width - wm_width) // 2, 10)
    elif position_choice == "–≤–Ω–∏–∑—É":
        position = ((base_width - wm_width) // 2, base_height - wm_height - 10)
    elif position_choice == "–ø–æ —Ü–µ–Ω—Ç—Ä—É":
        position = ((base_width - wm_width) // 2, (base_height - wm_height) // 2)
    else:
        position = (base_width - wm_width - 10, base_height - wm_height - 10)

    # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –≤–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫
    transparent = Image.new("RGBA", base_image.size, (0, 0, 0, 0))
    transparent.paste(base_image, (0, 0))
    transparent.paste(watermark, position, mask=watermark)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ PNG (—á—Ç–æ–±—ã –Ω–µ —Ç–µ—Ä—è—Ç—å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å)
    result_path = image_path.replace(".jpg", "_watermarked.png").replace(".png", "_watermarked.png")
    transparent.save(result_path, "PNG")
    return result_path

# –ó–∞–ø—É—Å–∫–∞–µ–º Flask –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
keep_alive()

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
